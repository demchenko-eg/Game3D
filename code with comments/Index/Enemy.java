package Index;

import Input.Controller;

/**
 * Клас Enemy (Ворог).
 * Цей клас описує поведінку супротивника.
 * Ворог має просту систему навігації: він "слухає" кроки гравця.
 * Якщо гравець шумить поруч, ворог запам'ятовує це місце і йде туди.
 */
public class Enemy {

    /**
     * Поточні координати ворога на карті.
     * Використовуємо double для плавного переміщення (не по клітинках, а плавно між ними).
     */
    public double x, z;

    /**
     * Координати цілі (Target).
     * Це точка, куди ворог намагається дійти зараз.
     * Зазвичай це місце, де ворог востаннє "чув" гравця.
     */
    private double targetX;
    private double targetZ;

    /**
     * Прапорець: чи є у ворога активна ціль?
     * true - ворог почув гравця і йде перевіряти.
     * false - ворог стоїть на місці (або патрулює).
     */
    private boolean hasTarget = false;

    /**
     * Конструктор ворога.
     * Створює нового ворога у заданій точці.
     *
     * @param x Початкова координата X.
     * @param z Початкова координата Z.
     */
    public Enemy(double x, double z) {
        this.x = x;
        this.z = z;
        // Спочатку ціллю є сама позиція ворога (він стоїть на місці)
        this.targetX = x;
        this.targetZ = z;
    }

    /**
     * Метод tick (Оновлення логіки).
     * Викликається 60 разів на секунду. Тут відбувається "мислення" ворога.
     *
     * @param player Контролер гравця (щоб знати, де він і що робить).
     * @param level  Дані рівня (щоб знати про стіни).
     */
    public void tick(Controller player, Level level) {
        // 1. РОЗРАХУНОК ВІДСТАНІ ДО ГРАВЦЯ.
        // Використовуємо теорему Піфагора: c = sqrt(a^2 + b^2).
        // Це відстань по прямій лінії.
        double distToPlayer = Math.sqrt(Math.pow(player.x - x, 2) + Math.pow(player.z - z, 2));

        // Визначаємо, як далеко чує ворог.
        // Множимо на 10.0, щоб перевести ігрові одиниці у зрозумілу дистанцію.
        double hearingLimit = Game.enemyHearingRadius * 10.0;

        // 2. ЛОГІКА "СЛУХУ" (AI).
        // Ворог помічає гравця, якщо виконуються ТРИ умови:
        // 1. Гравець рухається (isMoving).
        // 2. Гравець НЕ крадеться (!isCrouching). Якщо крадеться - він безшумний.
        // 3. Гравець знаходиться в межах радіусу слуху (distToPlayer < hearingLimit).
        if (player.isMoving && !player.isCrouching && distToPlayer < hearingLimit) {
            // Ворог почув шум! Він оновлює свою ціль на поточну позицію гравця.
            targetX = player.x;
            targetZ = player.z;
            hasTarget = true;
        }

        // 3. РУХ ДО ЦІЛІ.
        if (hasTarget) {
            // Вектор напрямку до цілі (різниця координат)
            double dx = targetX - x;
            double dz = targetZ - z;

            // Відстань, яку залишилось пройти до цілі
            double distToTarget = Math.sqrt(dx*dx + dz*dz);

            // Якщо ми ще не дійшли (відстань більше 0.5 блоку)
            if (distToTarget > 0.5) {
                // НОРМАЛІЗАЦІЯ ВЕКТОРА.
                // Ми ділимо різницю координат на загальну відстань.
                // Це перетворює вектор довжиною distToTarget у вектор довжиною 1.
                // Це потрібно, щоб ворог рухався з однаковою швидкістю в будь-якому напрямку.
                dx /= distToTarget;
                dz /= distToTarget;

                // Визначаємо, скільки пройти за цей кадр (швидкість)
                double moveX = dx * Game.enemySpeed;
                double moveZ = dz * Game.enemySpeed;

                // ПЕРЕВІРКА КОЛІЗІЙ (СТІН).
                // Ми перевіряємо осі X та Z окремо.
                // Це дозволяє "ковзати" вздовж стін. Якщо ворог впирається в стіну прямо,
                // але ціль трохи збоку, він продовжить рухатися вздовж стіни.

                // Пробуємо зробити крок по X
                if (isFree(x + moveX, z, level)) {
                    x += moveX;
                }
                // Пробуємо зробити крок по Z
                if (isFree(x, z + moveZ, level)) {
                    z += moveZ;
                }
            } else {
                // Ми дійшли до точки, де чули гравця.
                // Зупиняємось і чекаємо нового шуму.
                hasTarget = false;
            }
        }
    }

    /**
     * Метод isFree (Чи вільно?).
     * Перевіряє, чи не застрягне ворог у стіні, якщо переміститься в точку (xx, zz).
     *
     * @param xx    Бажана координата X.
     * @param zz    Бажана координата Z.
     * @param level Посилання на рівень для перевірки блоків.
     * @return true, якщо місце вільне; false, якщо там стіна.
     */
    private boolean isFree(double xx, double zz, Level level) {
        // Радіус "тіла" ворога (Hitbox).
        // Ворог не є точкою, він має розмір 0.7x0.7 (0.35 * 2).
        double r = 0.35;

        // Ми перевіряємо чотири кути навколо центру ворога.
        // Якщо хоч один кут потрапляє в стіну (> 0), рух заборонено.

        // Лівий верхній кут
        if (level.getTile((int)(xx - r), (int)(zz - r)) > 0) return false;

        // Лівий нижній кут
        if (level.getTile((int)(xx - r), (int)(zz + r)) > 0) return false;

        // Правий верхній кут
        if (level.getTile((int)(xx + r), (int)(zz - r)) > 0) return false;

        // Правий нижній кут
        if (level.getTile((int)(xx + r), (int)(zz + r)) > 0) return false;

        // Якщо всі кути у порожньому просторі (блок 0)
        return true;
    }
}